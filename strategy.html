<html>
	<head>
		<meta charset= utf-8>
		<link rel="stylesheet" type="text/css" href="style.css"/>
		<link rel="stylesheet" type="text/css" href="menu.css"/>
		<link rel="stylesheet" type="text/css" href="spoiler.css"/>
		<title>Design-Patterns</title>
	</head>
<body>
	<div class="name">
		<p style='color:#A80A00'>Design</p><p style='color:#251918'>Patterns</p>
	</div>
	<div class="header">	
		<ul class="menu">
			<li><a href="patterns.html">Главная</a></li>
			<li><a>Основные </a>
			<ul class="menu">
				<li id="twoLine"><a href="delegationPattern.html">Шаблон делегирования </a></li>
				<li id="threeLine"><a href="FunctionalDesign.html">Шаблон функционального дизайна </a></li>
				<li><a href="interface.html">Интерфейс </a></li>
			</ul>
			</li>
			<li><a>Порождающие </a>
			<ul class="menu">
				<li id="twoLine"><a href="AbstactFactory.html">Абстрактная <br/> фабрика </a></li>
				<li><a href="singletone.html">Одиночка  </a></li>
			 </ul>
			</li>
			<li><a>Структурные </a>
			<ul class="menu">
				<li><a href="Composite.html">Компоновщик  </a></li>
				<li><a href="Bridge.html">Мост  </a></li>
			 </ul>
			</li>
			<li><a>Поведенческие </a>
			<ul class="menu">
				<li ><a href="strategy.html">Стратегия  </a></li>
				<li ><a href="Observer.html">Наблюдатель  </a></li>
			 </ul>
			</li>
			<li><a href="enter.html">Вход </a></li>	
		</ul>
	</div>
	<div class="main" height="900px">
		<div style='padding:10px;'>
			<h1>Стратегия</h1>
			<div id="info">
				<p>Стратегия (англ. Strategy) — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путем определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.
				</p>	
				<h2 style='padding-left:20px;'>Мотивы</h2>
								
				<ul style='padding:0; padding-left:20; font-size:20px; font-family:Georgian; padding-bottom:10px;'>
				<li>Программа должна обеспечивать различные варианты алгоритма или поведения</li>
				<li>Нужно изменять поведение каждого экземпляра класса</li>
				<li>Необходимо изменять поведение объектов на стадии выполнения</li>
				<li>Введение интерфейса позволяет классам-клиентам ничего не знать о классах, 
				реализующих этот интерфейс и инкапсулирующих в себе конкретные алгоритмы</li>	
				</ul>
				
				<h2 style='padding-left:20px;'>Способ решения</h2>
				<p style='padding-top:0'>				
					Отделение процедуры выбора алгоритма от его реализации. Это позволяет сделать выбор на основании контекста.
				</p>
				
				<h2 style='padding-left:20px;'>Участники</h2>
				<ul style='padding:0; padding-left:20; font-size:20px; font-family:Georgian; padding-bottom:10px;'>
				<li>Класс Strategy определяет, как будут использоваться различные алгоритмы.</li>
				<li>Конкретные классы ConcreteStrategy реализуют эти различные алгоритмы.</li>
				<li>Класс Context использует конкретные классы ConcreteStrategy посредством 
				ссылки на конкретный тип абстрактного класса Strategy. Классы Strategy и Context 
				взаимодействуют с целью реализации выбранного алгоритма (в некоторых случаях классу 
				Strategy требуется посылать запросы классу Context). Класс Context пересылает классу 
				Strategy запрос, поступивший от его класса-клиента.</li>
				</ul>
				
				<h2 style='padding-left:20px;'>Следствия</h2>
				<ul style='padding:0; padding-bottom:10px; padding-left:20; font-size:20px; font-family:Georgian;'>
				<li>Шаблон Strategy определяет семейство алгоритмов.</li>
				<li>Это позволяет отказаться от использования переключателей и/или условных операторов.</li>
				<li>Вызов всех алгоритмов должен осуществляться стандартным образом (все они должны иметь одинаковый интерфейс).</li>
				</ul>
				
				<h2 style='padding-left:20px;'>Реализация</h2>
				<p style='padding-top:0' >				
					Класс, который использует алгоритм (Context), включает абстрактный класс (Strategy), 
					обладающий абстрактным методом, определяющим способ вызова алгоритма. Каждый производный класс 
					реализует один требуемый вариант алгоритма. Замечание: метод вызова алгоритма не должен быть 
					абстрактным, если требуется реализовать некоторое поведение, принимаемое по умолчанию.
				</p>
				
				<h2 style='padding-left:20px;'>Использование</h2>
					<p style='padding-top:0'>				
						Архитектура Microsoft WDF основана на этом паттерне. У каждого объекта «драйвер» и «устройство» 
						есть неизменяемая часть, вшитая в систему, в которой регистрируется изменяемая часть (стратегия), 
						написанная в конкретной реализации. Изменяемая часть может быть и вовсе пустой, что даст ничего 
						не делающий драйвер, но при этом способный участвовать в PnP и управлении питанием.
						Библиотека ATL содержит в себе набор классов threading model, которые являются стратегиями 
						(различными реализациями Lock/Unlock, которые потом используются основными классами системы). 
						При этом в этих стратегиях используется статический полиморфизм через параметр шаблона, а не 
						динамический полиморфизм через виртуальные методы.
					</p>
				
			</div>
			
			<div>
				<p>Пример на C#</p>
				<div class="spoiler">

					<!--* Добавлен tabindex="-1" для снятия фокуса при переходе по "tab" -->
					<input style="width:360px;height:45px;" type="checkbox" tabindex="-1" >
					<div class="box">
						<blockquote class="Untext">
						<pre>
using System;

namespace DesignPatterns.Behavioral.Strategy
{
    // Класс реализующий конкретную стратегию, должен наследовать этот интерфейс
    // Класс контекста использует этот интерфейс для вызова конкретной стратегии
    public interface IStrategy
    {
        void Algorithm();
    }

    // Первая конкретная реализация-стратегия.
    public class ConcreteStrategy1 : IStrategy
    {
        public void Algorithm()
        {
            Console.WriteLine("Выполняется алгоритм стратегии 1.");
        }
    }

    // Вторая конкретная реализация-стратегия.
    // Реализаций может быть сколько угодно много.
    public class ConcreteStrategy2 : IStrategy
    {
        public void Algorithm()
        {
            Console.WriteLine("Выполняется алгоритм стратегии 2.");
        }
    }

    // Контекст, использующий стратегию для решения своей задачи.
    public class Context
    {
        // Ссылка на интерфейс IStrategy
        // позволяет автоматически переключаться между конкретными реализациями
        // (другими словами, это выбор конкретной стратегии).
        private IStrategy _strategy;

        // Конструктор контекста.
        // Инициализирует объект стратегией.
        public Context(IStrategy strategy)
        {
            _strategy = strategy;
        }

        // Метод для установки стратегии.
        // Служит для смены стратегии во время выполнения.
        // В C# может быть реализован также как свойство записи.
        public void SetStrategy(IStrategy strategy)
        {
            _strategy = strategy;
        }

        // Некоторая функциональность контекста, которая выбирает
        //стратегию и использует её для решения своей задачи.
        public void ExecuteOperation()
        {
            _strategy.Algorithm();
        }
    }

    // Класс приложения.
    // В данном примере выступает как клиент контекста.
    public static class Program
    {
        // Точка входа в программу.
        public static void Main()
        {
            // Создаём контекст и инициализируем его первой стратегией.
            Context context = new Context(new ConcreteStrategy1());
            // Выполняем операцию контекста, которая использует первую стратегию.
            context.ExecuteOperation();
            // Заменяем в контексте первую стратегию второй.
            context.SetStrategy(new ConcreteStrategy2());
            // Выполняем операцию контекста, которая теперь использует вторую стратегию.
            context.ExecuteOperation();
        }
    }
}

						</pre>
						
						</blockquote>
					</div>

				</div>
					
			</div>
		</div>
			
	</div>
	<div class="bot">
		<div align="center" style='padding-top:200' >
			<a href="feedback.html">Обратная связь</a>
		</div>	
	</div>	
	</body>
</html>